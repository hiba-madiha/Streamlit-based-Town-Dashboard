"""
bill_entry.py – Streamlit page for monthly bill entry & collection tracking

Changes vs. original
────────────────────
• Schema now stores *due* and *paid* separately (pending = due − paid).
• Admin edits only the *_paid columns; *_due and *_pending are read-only.
• Validation ensures paid ≤ due and 0 payment for services not availed.
"""

import sqlite3
from contextlib import closing
from datetime import date
from pathlib import Path

import pandas as pd
import streamlit as st

# ──────────────────────────────────────────────────────────────────────────────
# Globals & defaults (editable at runtime)
# ──────────────────────────────────────────────────────────────────────────────
DB_PATH = Path(__file__).parent.parent / "residents.db"
DEFAULT_WATER_DUE      = 500.0
DEFAULT_SECURITY_DUE   = 500.0
DEFAULT_SANITATION_DUE = 500.0


# ──────────────────────────────────────────────────────────────────────────────
# DB helpers
# ──────────────────────────────────────────────────────────────────────────────
def get_conn():
    """Return a singleton SQLite connection stored in session_state."""
    if "_db_conn" not in st.session_state:
        conn = sqlite3.connect(DB_PATH, check_same_thread=False)
        conn.execute("PRAGMA foreign_keys = 1")
        st.session_state["_db_conn"] = conn
    return st.session_state["_db_conn"]




def initialise_schema():
    """Ensure `bills` has the new *_due and *_paid columns."""
    conn = get_conn()
    with closing(conn.cursor()) as cur:
        # 1. Create table if it never existed
        cur.execute("""
            CREATE TABLE IF NOT EXISTS bills (
                id               INTEGER PRIMARY KEY AUTOINCREMENT,
                resident_id      INTEGER NOT NULL,
                billing_month    TEXT    NOT NULL,
                -- new model
                water_due        REAL,
                security_due     REAL,
                sanitation_due   REAL,
                water_paid       REAL DEFAULT 0,
                security_paid    REAL DEFAULT 0,
                sanitation_paid  REAL DEFAULT 0,
                -- legacy columns (if present) are ignored here
                UNIQUE (resident_id, billing_month),
                FOREIGN KEY (resident_id) REFERENCES residents(id) ON DELETE CASCADE
            )
        """)
        conn.commit()

        # 2. Add missing columns (old DB created by the previous version)
        needed_cols = [
            ("water_due",      "REAL"),
            ("security_due",   "REAL"),
            ("sanitation_due", "REAL"),
            ("water_paid",      "REAL DEFAULT 0"),
            ("security_paid",   "REAL DEFAULT 0"),
            ("sanitation_paid", "REAL DEFAULT 0"),
        ]

        # figure out what columns the table already has
        cur.execute("PRAGMA table_info(bills)")
        existing = {row[1] for row in cur.fetchall()}  # row[1] == column name

        for col_name, col_type in needed_cols:
            if col_name not in existing:
                cur.execute(f"ALTER TABLE bills ADD COLUMN {col_name} {col_type}")
        conn.commit()



# ──────────────────────────────────────────────────────────────────────────────
# Data loading
# ──────────────────────────────────────────────────────────────────────────────
def load_residents() -> pd.DataFrame:
    """Return residents DF with resident_id as the index."""
    sql = """
        SELECT id AS resident_id,
               house_no,
               street_name,
               owner_name,
               owner_phone,
               facility_water,
               facility_security,
               facility_sanitation
        FROM residents
        ORDER BY street_name, house_no
    """
    df = pd.read_sql_query(sql, get_conn())
    return df.set_index("resident_id")


def load_existing_bills(month: str) -> pd.DataFrame:
    """Load any existing bills for `month` (both due & paid)."""
    sql = """
        SELECT resident_id,
               water_due,  security_due,  sanitation_due,
               water_paid, security_paid, sanitation_paid
        FROM bills
        WHERE billing_month = ?
    """
    df = pd.read_sql_query(sql, get_conn(), params=(month,))
    return df.set_index("resident_id")


# ──────────────────────────────────────────────────────────────────────────────
# Persisting changes
# ──────────────────────────────────────────────────────────────────────────────
def save_bills(bills_df: pd.DataFrame, month: str):
    """Insert or update bills for the given month in a single transaction."""
    conn = get_conn()
    with closing(conn.cursor()) as cur, conn:
        for resident_id, row in bills_df.iterrows():
            cur.execute(
                """
                INSERT INTO bills (
                    resident_id, billing_month,
                    water_due,    security_due,    sanitation_due,
                    water_paid,   security_paid,   sanitation_paid
                ) VALUES (?,?,?,?,?,?,?,?)
                ON CONFLICT(resident_id, billing_month) DO UPDATE SET
                    water_due      = excluded.water_due,
                    security_due   = excluded.security_due,
                    sanitation_due = excluded.sanitation_due,
                    water_paid     = excluded.water_paid,
                    security_paid  = excluded.security_paid,
                    sanitation_paid= excluded.sanitation_paid
                """,
                (
                    int(resident_id),
                    month,
                    float(row["water_due"]  or 0),
                    float(row["security_due"]  or 0),
                    float(row["sanitation_due"]  or 0),
                    float(row["water_paid"] or 0),
                    float(row["security_paid"] or 0),
                    float(row["sanitation_paid"] or 0),
                ),
            )


# ──────────────────────────────────────────────────────────────────────────────
# Main UI
# ──────────────────────────────────────────────────────────────────────────────
def render():
    initialise_schema()
    st.header("💵 Monthly Bill Entry")

    # ─── 1. Pick billing month ────────────────────────────────────────────
    today = date.today()
    default_month_date = date(today.year, today.month, 1)
    month_date = st.date_input(
        "Billing month", default_month_date, format="YYYY/MM/DD"
    )
    billing_month = month_date.strftime("%Y-%m")
    st.caption(f"Entering bills for **{billing_month}**")

    # ─── 2. Set default *dues* for the month ──────────────────────────────
    st.subheader("Default charges for this month (per house)")
    c1, c2, c3 = st.columns(3)
    with c1:
        default_water_due = st.number_input(
            "Water – Due", min_value=0.0, value=DEFAULT_WATER_DUE, step=50.0
        )
    with c2:
        default_security_due = st.number_input(
            "Security – Due", min_value=0.0, value=DEFAULT_SECURITY_DUE, step=50.0
        )
    with c3:
        default_sanitation_due = st.number_input(
            "Sanitation – Due",
            min_value=0.0,
            value=DEFAULT_SANITATION_DUE,
            step=50.0,
        )

    # ─── 3. Load residents & any existing bills ───────────────────────────
    residents = load_residents()
    existing  = load_existing_bills(billing_month)

    # ─── 4. Merge into working DF (one row per resident) ──────────────────
    for svc, default_due in [
        ("water",      default_water_due),
        ("security",   default_security_due),
        ("sanitation", default_sanitation_due),
    ]:
        residents[f"{svc}_due"] = (
            pd.to_numeric(existing.get(f"{svc}_due"), errors="coerce")
              .fillna(default_due)
              .astype(float)
        )
        residents[f"{svc}_paid"] = (
            pd.to_numeric(existing.get(f"{svc}_paid"), errors="coerce")
              .fillna(0.0)
              .astype(float)
        )
        residents[f"{svc}_pending"] = (
            residents[f"{svc}_due"] - residents[f"{svc}_paid"]
        )

    residents["Save?"] = False  # checkbox column

    # ─── 5. Disable editing where service not availed ─────────────────────
    water_disabled      = [not bool(x) for x in residents["facility_water"]]
    security_disabled   = [not bool(x) for x in residents["facility_security"]]
    sanitation_disabled = [not bool(x) for x in residents["facility_sanitation"]]

    # ─── 6. Column configuration for data_editor ──────────────────────────
    col_cfg = {
        "Save?": st.column_config.CheckboxColumn(required=False),

        # DUE columns – readonly
        "water_due":      st.column_config.NumberColumn("Water – Due",      disabled=True, format="%.0f"),
        "security_due":   st.column_config.NumberColumn("Security – Due",   disabled=True, format="%.0f"),
        "sanitation_due": st.column_config.NumberColumn("Sanitation – Due", disabled=True, format="%.0f"),

        # PAID columns – editable, possibly disabled per-row
        "water_paid":      st.column_config.NumberColumn("Water – Paid",      step=50.0, format="%.0f", disabled=water_disabled),
        "security_paid":   st.column_config.NumberColumn("Security – Paid",   step=50.0, format="%.0f", disabled=security_disabled),
        "sanitation_paid": st.column_config.NumberColumn("Sanitation – Paid", step=50.0, format="%.0f", disabled=sanitation_disabled),

        # PENDING columns – derived, readonly
        "water_pending":      st.column_config.NumberColumn("Water – Pending",      disabled=True, format="%.0f"),
        "security_pending":   st.column_config.NumberColumn("Security – Pending",   disabled=True, format="%.0f"),
        "sanitation_pending": st.column_config.NumberColumn("Sanitation – Pending", disabled=True, format="%.0f"),
    }

    display_cols = [
        "Save?",
        "house_no",
        "street_name",
        "owner_name",
        "owner_phone",
        #
        "water_due", "water_paid", "water_pending",
        "security_due", "security_paid", "security_pending",
        "sanitation_due", "sanitation_paid", "sanitation_pending",
    ]

    edited = st.data_editor(
        residents[display_cols],
        column_config=col_cfg,
        disabled=["house_no", "street_name", "owner_name", "owner_phone"],
        hide_index=True,
        key="bill_editor",
        use_container_width=True,
    )

    # ─── 7. Save button ───────────────────────────────────────────────────
    if st.button("💾 Save selected bills", type="primary"):
        to_save = edited.loc[edited["Save?"].fillna(False)].copy()
        if to_save.empty:
            st.warning("Please tick at least one row before saving.")
            st.stop()

        # Validation 1: service not availed ⇒ no payment
        errors = []
        for svc, flag_col in [
            ("water",      "facility_water"),
            ("security",   "facility_security"),
            ("sanitation", "facility_sanitation"),
        ]:
            mask = ~residents[flag_col] & (to_save[f"{svc}_paid"] > 0)
            if mask.any():
                houses = ", ".join(to_save.loc[mask, "house_no"].astype(str))
                errors.append(f"Cannot pay **{svc}** for houses without that service: {houses}")
        # Validation 2: paid cannot exceed due
        for svc in ("water", "security", "sanitation"):
            mask = to_save[f"{svc}_paid"] > to_save[f"{svc}_due"]
            if mask.any():
                houses = ", ".join(to_save.loc[mask, "house_no"].astype(str))
                errors.append(f"Paid **{svc}** exceeds due for house(s): {houses}")

        if errors:
            st.error("\n".join(errors))
            st.stop()

        # Ready to persist
        save_bills(
            to_save[
                [
                    "water_due", "security_due", "sanitation_due",
                    "water_paid", "security_paid", "sanitation_paid",
                ]
            ],
            billing_month,
        )
        st.success("✅ Bills saved successfully!")
        st.rerun()


# ──────────────────────────────────────────────────────────────────────────────
# Entrypoint
# ──────────────────────────────────────────────────────────────────────────────
if __name__ == "__main__":
    render()


















































------------------------------------------bill-----------------------------------------------

"""
bill_entry.py – Monthly Bill Entry & Payments Sheet
────────────────────────────────────────────────────────────────────────────
Streamlit page that lets the treasurer
• pick a month,
• set default Water / Security / Sanitation charges for that month,
• edit each resident’s actual bill or amount paid,
• see an auto-calculated “pending” column (= charges − paid),
• save everything atomically in SQLite.

NOTE: st.set_page_config() should be called in your main entry script,
      not here.
"""

from __future__ import annotations

import sqlite3
from contextlib import closing
from datetime import date
from pathlib import Path

import pandas as pd
import streamlit as st

# ──────────────────────────────────────────────────────────────────────────────
# Globals & defaults
# ──────────────────────────────────────────────────────────────────────────────
DB_PATH = Path(__file__).parent.parent / "residents.db"

DEFAULT_WATER_BILL      = 500
DEFAULT_SECURITY_BILL   = 500
DEFAULT_SANITATION_BILL = 1_000


# ──────────────────────────────────────────────────────────────────────────────
# Database helpers
# ──────────────────────────────────────────────────────────────────────────────
def get_conn() -> sqlite3.Connection:
    """Return a singleton SQLite connection held in session_state."""
    if "_db_conn" not in st.session_state:
        conn = sqlite3.connect(DB_PATH, check_same_thread=False)
        conn.execute("PRAGMA foreign_keys = 1")
        st.session_state["_db_conn"] = conn
    return st.session_state["_db_conn"]


# Ensure the bills table exists and has the required columns
with closing(get_conn().cursor()) as cur:
    cur.execute(
        """
        CREATE TABLE IF NOT EXISTS bills (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            resident_id     INTEGER NOT NULL,
            billing_month   TEXT    NOT NULL,  -- 'YYYY-MM'
            water_bill      REAL    DEFAULT 0,
            security_bill   REAL    DEFAULT 0,
            sanitation_bill REAL    DEFAULT 0,
            amount_paid     REAL    DEFAULT 0,
            UNIQUE (resident_id, billing_month),
            FOREIGN KEY (resident_id) REFERENCES residents(id) ON DELETE CASCADE
        )
        """
    )

    # One-time migration: add amount_paid if DB predates this script
    cur.execute("PRAGMA table_info(bills)")
    if "amount_paid" not in {row[1] for row in cur.fetchall()}:
        cur.execute("ALTER TABLE bills ADD COLUMN amount_paid REAL DEFAULT 0")

    get_conn().commit()


# ──────────────────────────────────────────────────────────────────────────────
# Data helpers
# ──────────────────────────────────────────────────────────────────────────────
def load_residents() -> pd.DataFrame:
    """Return residents DataFrame with resident_id as index."""
    sql = """
        SELECT id AS resident_id,
               house_no,
               street_name,
               owner_name,
               owner_phone,
               facility_water,
               facility_security,
               facility_sanitation
        FROM residents
        ORDER BY street_name, house_no
    """
    return pd.read_sql_query(sql, get_conn()).set_index("resident_id")


def load_existing_bills(month: str) -> pd.DataFrame:
    """Return any existing bills/payments for the selected month."""
    sql = """
        SELECT resident_id,
               water_bill, security_bill, sanitation_bill,
               amount_paid
        FROM bills
        WHERE billing_month = ?
    """
    return (
        pd.read_sql_query(sql, get_conn(), params=(month,))
        .set_index("resident_id")
    )


def save_bills(bills_df: pd.DataFrame, month: str) -> None:
    """Insert or update bills & payments in a single transaction."""
    conn = get_conn()
    with closing(conn.cursor()) as cur, conn:
        for resident_id, row in bills_df.iterrows():
            cur.execute(
                """
                INSERT INTO bills (
                    resident_id, billing_month,
                    water_bill, security_bill, sanitation_bill,
                    amount_paid
                ) VALUES (?,?,?,?,?,?)
                ON CONFLICT(resident_id, billing_month) DO UPDATE SET
                    water_bill      = excluded.water_bill,
                    security_bill   = excluded.security_bill,
                    sanitation_bill = excluded.sanitation_bill,
                    amount_paid     = excluded.amount_paid
                """,
                (
                    int(resident_id),
                    month,
                    float(row["water_bill"]      or 0),
                    float(row["security_bill"]   or 0),
                    float(row["sanitation_bill"] or 0),
                    float(row["amount_paid"]     or 0),
                ),
            )


# ──────────────────────────────────────────────────────────────────────────────
# Page render
# ──────────────────────────────────────────────────────────────────────────────
def render() -> None:
    st.header("💵 Monthly Bill Entry & Payments")

    # 1 — Select billing month
    today = date.today()
    default_month_date = date(today.year, today.month, 1)
    month_date   = st.date_input("Billing month", default_month_date, format="YYYY/MM/DD")
    billing_month = month_date.strftime("%Y-%m")
    st.caption(f"Entering bills for **{billing_month}**")

    # 2 — Default charge inputs
    st.subheader("Default charges for this month (per house)")
    c1, c2, c3 = st.columns(3)
    default_water = c1.number_input("Water bill (Rs)",      value=DEFAULT_WATER_BILL,      step=100)
    default_security = c2.number_input("Security bill (Rs)",   value=DEFAULT_SECURITY_BILL,   step=100)
    default_sanitation = c3.number_input("Sanitation bill (Rs)", value=DEFAULT_SANITATION_BILL, step=100)

    # 3 — Load data
    residents = load_residents()
    existing  = load_existing_bills(billing_month)

    # 4 — Merge & apply defaults
    for col in ["water_bill", "security_bill", "sanitation_bill", "amount_paid"]:
        residents[col] = existing[col]

    # set default charges only where NaN AND the service is availed
    mask = residents["facility_water"].astype(bool) & residents["water_bill"].isna()
    residents.loc[mask, "water_bill"] = default_water
    mask = residents["facility_security"].astype(bool) & residents["security_bill"].isna()
    residents.loc[mask, "security_bill"] = default_security
    mask = residents["facility_sanitation"].astype(bool) & residents["sanitation_bill"].isna()
    residents.loc[mask, "sanitation_bill"] = default_sanitation

    residents["amount_paid"].fillna(0, inplace=True)

    # 5 — Pending (charges − paid)
    residents["pending"] = (
        residents[["water_bill", "security_bill", "sanitation_bill"]].sum(axis=1)
        - residents["amount_paid"]
    )

    # 6 — Checkbox column for saving
    residents["Save?"] = False

    # 7 — Per-row disabled lists
    water_disabled      = (~residents["facility_water"].astype(bool)).tolist()
    security_disabled   = (~residents["facility_security"].astype(bool)).tolist()
    sanitation_disabled = (~residents["facility_sanitation"].astype(bool)).tolist()

    # 8 — Column configuration
    col_cfg = {
        "Save?": st.column_config.CheckboxColumn(required=False),

        "water_bill": st.column_config.NumberColumn(
            "Water Bill", step=100.0, format="%.0f", disabled=water_disabled
        ),
        "security_bill": st.column_config.NumberColumn(
            "Security Bill", step=100.0, format="%.0f", disabled=security_disabled
        ),
        "sanitation_bill": st.column_config.NumberColumn(
            "Sanitation Bill", step=100.0, format="%.0f", disabled=sanitation_disabled
        ),
        "amount_paid": st.column_config.NumberColumn(
            "Paid", step=100.0, format="%.0f"
        ),
        "pending": st.column_config.NumberColumn(
            "Pending", format="%.0f", disabled=True
        ),
    }

    display_cols = [
        "Save?",
        "house_no", "street_name", "owner_name", "owner_phone",
        "water_bill", "security_bill", "sanitation_bill",
        "amount_paid", "pending",
    ]

    # 9 — Data editor
    edited = st.data_editor(
        residents[display_cols],
        column_config=col_cfg,
        disabled=["house_no", "street_name", "owner_name", "owner_phone", "pending"],
        hide_index=True,
        key="bill_editor",
        use_container_width=True,
    )

    # Live pending update
    edited["pending"] = (
        edited[["water_bill", "security_bill", "sanitation_bill"]].sum(axis=1)
        - edited["amount_paid"]
    )

    # 10 — Save button
    if st.button("💾 Save selected rows", type="primary"):
        rows_to_save = edited[edited["Save?"].fillna(False)].copy()
        if rows_to_save.empty:
            st.warning("Please tick at least one row before saving.")
            st.stop()

        # Fill NaNs with zeros before persistence
        numeric_cols = ["water_bill", "security_bill", "sanitation_bill", "amount_paid"]
        rows_to_save[numeric_cols] = rows_to_save[numeric_cols].fillna(0)

        save_bills(rows_to_save[numeric_cols], billing_month)
        st.success("✅ Bills and payments saved!")
        st.rerun()


# Entrypoint for local debugging
if __name__ == "__main__":
    render()





































---------------------------------------------------defaulters----------------------------------------------------


"""
defaulters.py — List residents with pending utility charges
───────────────────────────────────────────────────────────────────────────
Works alongside bill_entry.py.  No DB schema changes needed.
"""

from __future__ import annotations
import calendar
import sqlite3
from contextlib import closing
from datetime import date, datetime
from pathlib import Path

import pandas as pd
import streamlit as st

# ──────────────────────────────────────────────────────────────────────────
# Globals / defaults
# ──────────────────────────────────────────────────────────────────────────
DB_PATH = Path(__file__).parent.parent / "residents.db"

DEFAULT_WATER_DUE      = 500
DEFAULT_SECURITY_DUE   = 500
DEFAULT_SANITATION_DUE = 1_000


# ──────────────────────────  DB helpers  ────────────────────────────────
def get_conn() -> sqlite3.Connection:
    if "_db_conn" not in st.session_state:
        conn = sqlite3.connect(DB_PATH, check_same_thread=False)
        conn.execute("PRAGMA foreign_keys = 1")
        st.session_state["_db_conn"] = conn
    return st.session_state["_db_conn"]


def load_residents() -> pd.DataFrame:
    """Basic resident info + facility flags; index = resident_id."""
    sql = """
        SELECT id AS resident_id,
               house_no, street_name, owner_name, owner_phone,
               facility_water, facility_security, facility_sanitation
        FROM residents
        ORDER BY street_name, house_no
    """
    return pd.read_sql_query(sql, get_conn()).set_index("resident_id")


def load_paid_for_month(yyyymm: str) -> pd.DataFrame:
    """Return paid amounts for a single month (index=resident_id)."""
    sql = """
        SELECT resident_id, water_bill, security_bill, sanitation_bill
        FROM bills WHERE billing_month = ?
    """
    return pd.read_sql_query(sql, get_conn(), params=(yyyymm,)).set_index("resident_id")


# ──────────────────────────────  UI  ────────────────────────────────────
def render() -> None:
    st.header("🚨 Defaulters")

    # 1 - Report type ----------------------------------------------------
    mode = st.radio("Report scope", ("Monthly", "Annual"), horizontal=True)

    if mode == "Monthly":
        month_dt = st.date_input(
            "Select month",
            value=date.today().replace(day=1),
            format="YYYY/MM/DD",
        )
        target_month = month_dt.strftime("%Y-%m")
        st.caption(f"Showing defaulters for **{target_month}**")
        years, months = [month_dt.year], [month_dt.month]  # helpers later
    else:  # Annual
        this_year = date.today().year
        year = st.selectbox("Select year", reversed(range(this_year - 5, this_year + 1)))
        st.caption(f"Showing defaulters for **{year}** (Jan – Dec)")
        years, months = [year], list(range(1, 13))
        target_month = None  # sentinel

    # 2 - Expected dues --------------------------------------------------
    st.subheader("Expected monthly charge per service")
    c1, c2, c3 = st.columns(3)
    due_water = c1.number_input("Water (Rs)",      min_value=0, value=int(DEFAULT_WATER_DUE),      step=100)
    due_secur = c2.number_input("Security (Rs)",   min_value=0, value=int(DEFAULT_SECURITY_DUE),   step=100)
    due_sanit = c3.number_input("Sanitation (Rs)", min_value=0, value=int(DEFAULT_SANITATION_DUE), step=100)

    # 3 - Service filters -----------------------------------------------
    st.subheader("Show defaulters for:")
    f_water      = st.checkbox("Water",      value=True)
    f_security   = st.checkbox("Security",   value=True)
    f_sanitation = st.checkbox("Sanitation", value=True)
    if not (f_water or f_security or f_sanitation):
        st.info("Tick at least one service to see results.")
        st.stop()

    # 4 - Gather data ----------------------------------------------------
    res = load_residents()

    # init paid columns to 0
    for col in ["water_paid", "security_paid", "sanitation_paid"]:
        res[col] = 0.0

    # loop months to accumulate paid amounts
    for yr in years:
        for mo in months:
            yyyymm = f"{yr}-{mo:02d}"
            monthly_paid = load_paid_for_month(yyyymm)
            for svc, col in [
                ("water_bill",      "water_paid"),
                ("security_bill",   "security_paid"),
                ("sanitation_bill", "sanitation_paid"),
            ]:
                res[col] += monthly_paid.get(svc, 0)

    # number of months considered (1 for monthly, 12 for annual)
    m_count = len(months)

    # 5 - Compute due & pending -----------------------------------------
    res["water_due"]      = res["facility_water"]      * due_water   * m_count
    res["security_due"]   = res["facility_security"]   * due_secur   * m_count
    res["sanitation_due"] = res["facility_sanitation"] * due_sanit   * m_count

    res["water_pending"]      = res["water_due"]      - res["water_paid"]
    res["security_pending"]   = res["security_due"]   - res["security_paid"]
    res["sanitation_pending"] = res["sanitation_due"] - res["sanitation_paid"]

    # filter rows --------------------------------------------------------
    mask = False
    if f_water:
        mask |= res["water_pending"] > 0
    if f_security:
        mask |= res["security_pending"] > 0
    if f_sanitation:
        mask |= res["sanitation_pending"] > 0
    defaulters = res[mask].copy()

    if defaulters.empty:
        st.success("🎉 No defaulters for the selected settings!")
        st.stop()

    # total pending per resident
    defaulters["Pending total"] = (
        defaulters["water_pending"]
        + defaulters["security_pending"]
        + defaulters["sanitation_pending"]
    )

    # serial numbers
    defaulters = defaulters.reset_index()
    defaulters.insert(0, "S.No", range(1, len(defaulters) + 1))

    # prepare display ----------------------------------------------------
    disp_cols = [
        "S.No", "house_no", "street_name", "owner_name", "owner_phone",
        "water_pending", "security_pending", "sanitation_pending", "Pending total",
    ]

    cfg = {
        "S.No":           st.column_config.NumberColumn("S.No", disabled=True, format="%.0f"),
        "house_no":       st.column_config.TextColumn("House #", disabled=True),
        "street_name":    st.column_config.TextColumn("Street",  disabled=True),
        "owner_name":     st.column_config.TextColumn("Owner",   disabled=True),
        "owner_phone":    st.column_config.TextColumn("Phone",   disabled=True),
        "water_pending":      st.column_config.NumberColumn("Water pending",      disabled=True, format="%.0f"),
        "security_pending":   st.column_config.NumberColumn("Security pending",   disabled=True, format="%.0f"),
        "sanitation_pending": st.column_config.NumberColumn("Sanitation pending", disabled=True, format="%.0f"),
        "Pending total":      st.column_config.NumberColumn("Total pending",      disabled=True, format="%.0f"),
    }

    st.subheader("Defaulters list")
    st.data_editor(
        defaulters[disp_cols],
        column_config=cfg,
        hide_index=True,
        disabled=disp_cols,  # entire grid read-only
        use_container_width=True,
    )

    # optional CSV download
    csv = defaulters[disp_cols].to_csv(index=False).encode()
    st.download_button("Download CSV", csv, file_name="defaulters.csv", mime="text/csv")


# standalone run
if __name__ == "__main__":
    render()
